### 05. 요구사항의 문서화 
#### 요구명세기법 
- 비정형 명세 기법  
자연어로 작성 표현 모표  
일관성 떨어짐 사용자 요구 표현을  
작업 흐름도와 다디어그램 사용해 작성  
  
- 정형 명세 기법  
수학으로 사용되는 증명 기술 이용해 작성  
사용자 요구 일관성 있는지 완전한지 검증 되는 장점  
수학지식 필요, 원리와 표기법 이용함. (ex: Z 정형 명세 언어)  
이 표기법으로 요구 정확히 하기, 이해할 수 있도록 하기  
  
#### 요구사항 검증 
완전성, 일관성, 명확성, 기능성,  
검증가능성, 추적사능성, 변경용이성  
  
### 목차 
01. 설계의 이해  
02. 설계의 원리  
03. 모듈화  
04. 사용자 인터페이스 설계  
  
tip: 구분석 명세서를 이용해서 개발 설계에 들어감.  
  
### 01. 설계의 이해 
건축: 의견교환 도안확정 최종 산출물로 설계도면이 만들어지고 기반해 건설  
소프트웨어: 명세서 작성 후 참조해 개발팀에서 설계서 만들고 기반해 구현 작업  
  
#### 요구분석과 설계 과정 차이   
요구분석: 요구분석명세서 -> 무엇what 개발할지 -> 개념적 추상적 -> 미고려: 운영체제 DBMS 프레임워크  
설계: 설계서 -> 어떻게(how) -> 사용환경 반영해 구체적 -> 비기능요구사항 제약사항 플랫폼(운영체제,미들웨어,프레임워크)  
  

#### 분할과 정복 
가능하면 한 개의 기능씩 되도록  
다시 꺼내 쓸 수 있도록 쪼개 쓰는 게 제일 좋다  
  
### 02. 설계의 원리 

- 추상화  
자신의 필요한 특징만 표현  
필요한 정보만 추출해 강조  
전기담당자에게 전기 배선도  
다른담당자에게는 다른 배선도  
  
(그냥 팁: 삼각형의 각 몇 도인지 계산 ABC 있을 때  
C 구하려면 180에서 A B 값 빼면 된다)  
  
#### 데이터추상화예시 - 스택 
![후위표기 보고 push와 pop](./Image/후위push-pop)  
  
고급언어: Z = X+Y;  
  
어셈블리언어:  
LOAD A, X  
ADD A, Y  
STORE Z, A  
  
기계어: 00100101  
10000110  
01000111  
  
#### 캡슐화 
사용자에게 사용법이나 기능 서비스만 제공하고  
내부는 함부로 변경할 수 없게 감추는 개념  
ptivate 해놓고 get class set class에 접근하는 것처럼  
  
#### 정보은닉 
(+) public 공개  
(-) 은닉 private  
(#) 부분공개 protected  
  
UML 기준 + - #  
```
#line_color 
-hight 

+fill_color()  
+erase()  
+area()  
```
  
#### 상속 
상위클래스 모든 거 하위클래스가 물려받음  
부모클래스 -> 자식클래스  
상속관계로 묶여서 구조 파악 쉽고  
상속관계 속한 클래스 데이터 메소드 추가 쉬움  
데이터 와 메서드를 변경할 때 상위에 있는 것만 수정 가능  
  
#### 다형성 - 오버라이딩(재정의) 
상위클래스에서 정의한 메서드 무시하고  
하위클래스에서 다시 정의해 사용하는 것  
  
### 03. 모듈화 
#### 모듈화 
덧셈 뺄셈 평균 합계 등의 기능들을  
어떻게 나누고 크기를 잡을지 정함.  
  
모듈화는 결국 하나 하나 기능을  
재사용할 수 있도록 잘 분할, 정복하는 것.  
  
하나의 기능(모듈)이 단순해질 수 있으며  
효율적으로 관리하고 유지보수 할 수 있음  
모듈을 재사용 할 수도 있음  
개발시간도 후반 가면 줄어듬  
  
#### 모듈평가기준1: 응집도 
우연적응집 논리적응집 시간적응집 절차적응집 교환적응집 순차적응집 기능적응집  
<---낮음(나쁨)---------응집도----------높음(좋음)-->  
  
- 응집도  
우연적응집도에 가까우면 나쁜품질  
절차적응집이면 중간 품질  
기능적응집이면 높은 품질인 편  
   
#### 모듈평가기준 - 응집도 간단 설명   
기능적응집: 단일기능 요소가 하나의 모듈  
순차적응집: 두 요소가 밀접하니 하나의 모듈로 묶을 이유가 있음   
교환적응집: 순차적응집보다 묶인 이유가 조금 약함. 응집력 약함  
시간적응집: 모듈 내 구성요소 기능 다르고 입력 요소 간 출력 순서 정해진 게 없음  
논리적응집: 구성요소간의 공통점이 있거나 관련 임무 존재하거나 기능 비슷해서 하나로 모듈 구성  
우연적응집: 말 그대로 우연히 모여 모듈 구성. 가위바위보로 피구 팀 뽑는 듯  
  
#### 모듈평가기준2: 결합도 
데이터결합 스팸트결합 제어결합 공통결합 내용결합  
<---낮음(좋음)---------결합도----------높음(나쁨)-->  
  
독립성이 좋아서 간섭이 낮은 게 좋은 거다.  

#### 모듈평가기준 - 결합도 간단 설명 
데이터결합: 매개변수를 통해 "데이터만 주고 받음"으로써 서로 간섭 최소화  
모듈 간 독립성이 보장되고, 관계가 단순해서 모듈 서로 미치는 영향 적고  
유지보수에 용이함.  
A -데이터-> B  
  
스탬프결합: 두 모듈 정보를 교환할 때  
필요한 데이터만 받고 싶은데 필요없는 데이터도 래코드 전체 넘어옴  
데이터 하나 변경되면 모듈에 있는 자료구조 싹 바꾸므로 간섭 높은 편.  
A -데이터구조-> B  
  
다음 시간, 03. 모듈화 -> 모듈평가기준 결합도 -> 스탬프결합 또 보고 제어결합...  
  
