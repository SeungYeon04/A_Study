클래스  
클래스 : 멤버변수/메소드(생성자메소드-특정 값으로 초기화하는 거, 일반메소드)  
객체 : new연산자  
메세지: 메소드, 객체명, 메소드()    
상속: extends, 자바는 단일상속만 가능  
  
오버로딩(중첩(같은 거 여러 개), 동일클래스 내에서 씀) 
vs 오버라이딩(치환(바꿔줌), 상속관계클래스)  
==> 이름은 동일하게 해놓고 결과는 다르게 나오게 하는 것. (다형성)  
==> 동일 인터페이스로 서로 다른 결과를 가져오는 기법(다형성)  
  
캡슐화  
추상화  
다형성  
  
*** 
  
저번에 배운 구조  
1. 클래스설계  
2. 객체(인스턴스)를 메모리에 생성  
3. 객체.메소드(메세지) 전달 (C기준 메소드는 함수)  
  
*** 
### 메소드 오버로딩 Overloading
```
package chaper01;

class Box10 {
	//오버로딩 
	int w; //가로 세로 깊이 멤버변수 
	int y; //이 위치는 자동 기본 디폴트값으로 초기화 될 거임 
	int d; 
	
	public Box10(int w, int y, int d) { //이름 같은 생성자메소드(매개변수)  
		this.w = w; 
		this.y = y; 
		this.d = d; 
	}
	
	//생성자 매소드를 중첩해서 사용 --> 메소드 오버로딩 (메소드 또 써재낌) 
	//오버로딩: 동일 클래스에 동일 메소드를 여러 개 사용하는 것. 메소드명 동일. 매개변수 개수 또는 타입은 달라야 함 
	public Box10(int w) {
		this.w = w;
	}
	
	public int calVol(int w, int y, int d) { //자바에선 같은 이름 클래스 가능 
		return w*y*d; 
	}
	
	public int calVol(int w) {
		return w*w*w; 
	}

	public double calVol(double w, double y, double d) { 
		return w*y*d; 
	}
}

public class Task24 { 
	public static void main(String[] args) {

		Box10 b1 = new Box10(2,3,4); //w 2크기 y 2 d깊이 2 
		
		System.out.println("박스부피: " + b1.w * b1.y * b1.d);
		System.out.println("calVol: " + b1.calVol(2,3,4)); //calVol(int w) 생성자 메소드 호출
 
		Box10 b2 = new Box10(2); 
		
		System.out.println("박스부피: " + b2.w * b2.w * b2.w); //다 같은 정사각형 
		System.out.println("calVol: " + b1.calVol(2.0,3.0,4.0)); // calVol(double w.. 오버로딩을 한 더블타입 호출 
		
		
		
		
	}

}
```
5. 2개의 정수의 합을 구하는 sum()과 3개의 정수의  
합을 구하는 sum()을 메소드 오버로딩을 이용하여 정의하세요.
```
class Calculator {
   // 여기에 정의하세요
}
public class Task {   public static void main(String args[]) {
       Calculation obj = new Calculation();
       obj.sum(10,20,30);
       obj.sum(10,20); 
   }
}
```
```
package chaper01;

class Calttzxc {
	   
	int num1; 
	int num2; 
    int num3; 
   
   void sum(int num1, int num2, int num3) {
	   System.out.println("값 세 개를 더한 sum의 값: " + (num1+num2+num3));
   }

   void sum(int num1, int num2) {
	   System.out.println("값 두 개를 더한 sum의 값: " + (num1+num2));
   }
}



public class Task25 {   
	public static void main(String args[]) {
		Calttzxc obj = new Calttzxc();
       		obj.sum(10,20,30);
       		obj.sum(10,20);  
   }
}
```
*** 
오버로딩 = 같은 이름의 메소드를 여러 개 쓸 수 있게 만드는 것  
하지만 매개변수의 갯수나 타입 자료형만 다르고 동일한 메소드 쓰게 하는 것  
같은 메소드 여러 개 중첩하기  
  
*** 
### 오버라이딩 @Override 
오버라이딩 조건  
상속관계인 클래스에서 동일한 메소드를 치환해서 사용하는 기법  
메소드명, 매개변수, 리턴타입까지 모두 동일해야 함.  
  
```
package chaper01;

//오버라이딩 조건 
//상속관계의 클래스에서 동일한 메소드를 치환해서 사용하는 기법 
//메소드명, 매개변수, 리턴타입까지 모두 동일해야 함. 

class A {
	public void getName() {
		System.out.println("A 클래스입니다.");
	}

	@Override
	public String toString() { //Object꺼 완전 위에꺼 toString 사용. 
		return "Class A"; 
	}
	
	//메인에서 이걸 쓰면 
	//A a = new A(); 
    //System.out.println(a);
	//이상한 주소 나오는데 toString값 바꿔놓으면 그거 출력함 
}

class B extends A { //아빠꺼 튜닝해서 쓰기 = 치환 

	@Override
	public void getName() {
		// this는 나 super은 아빠 
		//super.getName();
		System.out.println("B 클래스입니다."); //getName의 내용만 튜닝해서 쓰기 
	}

	@Override
	public String toString() {
		
		return "Class B";
	} 
}

public class Task26 {   
	public static void main(String args[]) {

       B b = new B(); 
       b.getName(); 
       
       A a = new A(); 
       System.out.println(a);
       
       //B 클래스입니다.
       //Class A
   }
}
```

*** 
### 오버로딩 오버라이딩 차이점 
```
===> 오버로딩: 동일한 클래스 내에서 동일한 메소드를 중첩해서 사용하는 것  
	매개변수의 갯수 또는 자료형은 달라야 함  
===> 오버라이딩: 상속관계 클래스에서  
	상위 클래스의 메소드를 가져다가 수정해서 사용하는 기법  
	매개변수의 갯수 또는 자료형까지 동일해야 함 
```
  
#### 오버로딩 
```
   void sum(int num1, int num2, int num3) {
	   System.out.println("값 세 개를 더한 sum의 값: " + (num1+num2+num3));
   }

   void sum(int num1, int num2) {
	   System.out.println("값 두 개를 더한 sum의 값: " + (num1+num2));
   }

       obj.sum(10,20,30);
       obj.sum(10,20);  
```
#### 오버라이딩 
```
class A {
	public void getName() {
		System.out.println("A 클래스입니다.");
	}
} 

class B extends A { 

	@Override
	public void getName() { 
		System.out.println("B 클래스입니다."); //getName의 내용만 튜닝해서 쓰기 
	}
```
  
*** 
  
### 캡슐화와 getter메소드 
```
package chaper01;


class Box11 { 
	//이건 캡슐화 - 안에 영양성분을 봐야 알 수 있는 캡슐약 
	private int w; //Box11에서만 접근 가능해 - 정보를 은닉해 정보를 보호 
	private int h; 
	private int d; 

	public Box11(int w, int h, int d) {
		this.w = w; 
		this.h = h; 
		this.d = d; 
	}
	
	public int getW() { //w를 직접은 못 건들고 쓸 거면 이거 써! 
		return w; 
	}
	
	public int getH() { //멤버변수 숨기고 공개인터페이스 공개메소드 - getter메소드 
		return h; 
	}
	
	public int getD() { 
		return d; 
	}
}

public class Task27 {   
	public static void main(String args[]) {
		
		Box11 b1 = new Box11(2,3,4); 
		System.out.println("박스의 길이: "+b1.getW()); //다른 클래스는 접근 불가 Box11.w is not visible
		System.out.println("박스의 높이: "+b1.getH()); 
		System.out.println("박스의 깊이: "+b1.getD()); 
		
		
	}
}
```
#### 소스로 만든 get set 
```
package chaper01;


class Box11 { 
	//이건 캡슐화 - 안에 영양성분을 봐야 알 수 있는 캡슐약 
	private int w; //Box11에서만 접근 가능해 - 정보를 은닉해 정보를 보호 
	private int h; 
	private int d; 

	public Box11(int w, int h, int d) {
		this.w = w; 
		this.h = h; 
		this.d = d; 
	}

	public int getW() {
		return w;
	}

	public void setW(int w) {
		this.w = w;
	}

	public int getH() {
		return h;
	}

	public void setH(int h) {
		this.h = h;
	}

	public int getD() {
		return d;
	}

	public void setD(int d) {
		this.d = d;
	}
	
	
}

public class Task27 {   
	public static void main(String args[]) {
		
		Box11 b1 = new Box11(2,3,4); 
		System.out.println("박스의 길이: "+b1.getW()); //다른 클래스는 접근 불가 Box11.w is not visible
		System.out.println("박스의 높이: "+b1.getH()); 
		System.out.println("박스의 깊이: "+b1.getD()); 
		
		b1.setW(20); 
		b1.setH(30); 
		b1.setD(40); 
		
		System.out.println("박스의 길이: "+b1.getW()); //20
		System.out.println("박스의 높이: "+b1.getH()); //30
		System.out.println("박스의 깊이: "+b1.getD()); //40 
	}
}
```
### 라면 get set 
```
package chaper01;


class Ramyon2 { 

	private String breand; //함부로 수정 못하게. 특히 멤버변수는 직접 수정 못하게. 
	private String name; 
	private int price;
	
	public String getBreand() {
		return breand;
	}
	public void setBreand(String breand) {
		this.breand = breand;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getPrice() {
		return price;
	}
	public void setPrice(int price) {
		this.price = price;
	} 
	
	
}

public class Task27 { 
	public static void main(String args[]) {
		Ramyon2 r = new Ramyon2();  
		r.setBreand("농심"); 
		r.setName("신라면"); 
		r.setPrice(1500); 
		
		System.out.println("라면 브랜드 : " + r.getBreand() + "\n라면의 이름: " + r.getName() + "\n라면의 가격: " + r.getPrice());
	}
}
```
### 접근한정자 정리 (캡슐화를 위한 키워드) 
public - 어디서든 접근 가능 (public int a;)  
default - 같은 패키지에서만 접근 가능 (그냥 int a;)  
private - 해당 클래스에서만 접근 가능 (private int a;)  

***
### 캡슐화 이용 참조 테스트 
```
-- sample1  
- A.java
- Task.java
-- sample2
- B.java
- Task.java 
```
#### smaple1 -> A.java
```
package smaple1;

public class A {
	private int a ; 
	int b; 
	public int c; 
}
```
#### smaple1 -> Task.java 
```
package smaple1;

public class Task {
	public static void main(String[] args) {	
		A a = new A(); //같은 패키지의 다른 클래스 
		a.b = 10; //보안수준 안 걸음 
		a.c= 20; //public이라 됨 //a.a 는 private 에 다른 클래스라 안뜸 
	}
}

```
#### smaple2 -> B.java 
```
package smaple2;

public class B {
	private int a; 
	int b; 
	public int c; 
}
```
#### smaple2 -> Task.java
```
package smaple2;

import smaple1.A;

public class Task {

	public static void main(String[] args) {
		A a = new A(); //다른패키지에 있어서 못 찾음 import 해야 됨 
		
		a.c = 10; //다른 패키지라 public인 게 보임 
	}
}
```


