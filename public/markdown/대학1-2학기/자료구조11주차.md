INPUT  
미로의 크기  N <= 20  
미로의 배치도  
OUTPUT : 미로탈출경로  
RULR  
0 지나갈 수 있는 공간  
1 지나갈 수 없는 벽  
  
입구 1,1  
출구 N,N  
***  
미로의 크기 N  
미로의 지도 map  
  
1,1 시작 정점  
  
BFS수행  
  
새로운 방문정점이 N,N인가  
  
전체경로를 출력한다  
***
  
이게 잘 돌아가는진 모르겠지만  
대략 이런 구조임  
```
void BFS_adjList(graphType* g, int v) {
	grapgllode* w; 
	LQueueType* Q; 
	Q = createLinkedQueue(); 
	g->visited[v] = TRUE; 
	printf(" %c ", v + 65); 
	enLQueue(Q, v); 

	while (!isLQEmpty(Q)) {
		v = deLQueue(Q); 
		for(w = g->adjList_H[v]; w; w = w->link){
		if(!g->visited[w->vertex]){
			g->visited[w->vertex] = TRUE; 
			printf(" %c ", w->vertex + 65); 
			enLQueue(Q, w->vertex); 
		}
		}
	}

}
```
*** 
### 정렬 
#### 실행방법 (기준 키) 

비교식정렬: 비교할 키 값을 두 개씩 비교해 교한함으로 정렬 실행  
분배식정렬: 키 값을 기준으로 자료를 여러 개의 각 부분집합을 정렬함으로써 전체를 정렬하는 방식  

#### 정렬장소 
내부정렬: 컴퓨터 메모리 내부에 정렬  
외부정렬: 메모리의 외부인 보조 기억장치에 정렬  
  
|Sorting|장점|단점|
|------|---|---|
|버블정렬|구현쉬움|시간오래걸리고비효율적|
|선택정렬|구현쉬움, 비교횟수에 비해 교환이 적음|시간오래걸리고비효율적|
|퀵정렬|실행시간 빠른 편 O(NlogN)|Pivot에 의해 성능차 남, 최악의 경우 O(N^2)나 걸림|
|힙정렬|항상 O(NlogN)로 빠름|실제 시간이 다른 O(NlogN)이 정렬법들에 비해 오래걸림|
|병합정렬|항상 O(NlogN)로 빠름|추가메모리공간필요|
|삽입정렬|최선의 경루 O(N)으로 빠름. 성능 좋아 다른 정렬법 일부로 씀|최악의 경루 O(N^2)로, 데이터의 상태에 따라 성능차이가 난다|
|쉘 정렬|삽입정렬보다 더 빠른 정렬법|설정하는 간격에 따라 성능차이가 심함|
|기수정렬|O(N)라는 개빠른 속도를 갖는다|추가메모리 개많이 필요. 데이터타입 일정해야 함. 구현 조건이 많이 붙음|
|카운팅정렬|O(N)라는 개빠른 속도를 갖는다|추가메모리 공간 필요, 일부 값 때문에 메모리 낭비 심해질 수도 있음|

### 속도 
|Sorting|최악의경우(Worst)|일반의경우(Average)|최선의경우(Best)|
|------|---|---|---|
|버블정렬|O(N^2)|O(N^2)|O(N^2)|
|선택정렬|O(N^2)|O(N^2)|O(N^2)|
|퀵정렬|O(N^2)|O(NlogN)|O(NlogN)|
|힙정렬|O(NlogN)|O(NlogN)|O(NlogN)|
|병합정렬|O(NlogN)|O(NlogN)|O(NlogN)|
|삽입정렬|O(N^2)|O(N^2)|O(N)|
|쉘 정렬|O(N^2)|O(N^1.3,1.5)|O(N)|
|기수정렬|O(N)|O(N)|O(N)|
|카운팅정렬|O(N)|O(N)|O(N)|
