
### Byte단위 입출력 - 실습
```
import java.io.*;

public class ByteReadWriteExam{
    public static void main(String[] args){
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try{
            fis = new FileInputStream("data.txt"); //이 위치에서 
            fos = new FileOutputStream("copy.txt"); //이 이름으로 카피 
            //data.txt의 파일을 읽어서 그대로 copy.txt에 복사하려고 합니다.
            //이 아래에서 fis와 fos를 이용해서 파일 복사를 완성해 보세요.
            
            int rData = -1; //파일데이터를 저장하는 변수, 초깃값 -1
            
            //fis에서 .read()로 파일에서 한 바이트를 읽음 읽은 값을 rData에 저장, rData != -1 아직 읽을 데이터가 있으면 while조건이 true이니 반복 계속. == -1되면 멈춤 (그냥 끝이면 -1반환하거뎡) 
            while((rData = fis.read()) != -1) { 
                fos.write(rData); //fos내용을.적다 rData에 
            }
        }
        catch(Exception e){
            System.out.println(e);
        } 
        finally{
            //fis와 fos를 사용하고 나면 close해야 합니다.    
            try{
                fis.close();
                fos.close();
            }
            catch(Exception e){
                System.out.println(e);
            }
        }
    }
}
```

### Byte 단위 입출력 심화

#### 12번 파일 
```
package pack;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Programmers_MidllTest_12<E> { //제너릭 
	public static void main(String[] args) {
		long startTime = System.currentTimeMillis();
			FileInputStream fis = null; 
			FileOutputStream fos = null; 
			
			try {
				//이 파일을 읽어와서 
				fis = new FileInputStream("C:/Users/USER/eclipse-workspace/SeungYeon_JavaStudy1/src/pack/Programmers_MidllTest_12.java"); 
				//여기다가 적을 거다 
				fos = new FileOutputStream("byte.txt"); 
				
				int readData = -1; 
				while((readData = fis.read()) != -1) {
					fos.write(readData); //만들기 
				}
	
			} catch(Exception e) { 
				e.printStackTrace();
			} finally { //무조건실행? 
				try {
					fos.close(); //닫기 
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			long endTime = System.currentTimeMillis();
			System.out.println(endTime - startTime);
 		}
	}
```
실행시간: 8  
   
#### 13번 파일 
```
package pack;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Programmers_MidllTest_13<E> { //제너릭 
	public static void main(String[] args) {
			long startTime = System.currentTimeMillis();
			FileInputStream fis = null; 
			FileOutputStream fos = null; 
			
			try {
				//이 파일을 읽어와서 
				fis = new FileInputStream("C:/Users/USER/eclipse-workspace/SeungYeon_JavaStudy1/src/pack/Programmers_MidllTest_12.java"); 
				//여기다가 적을 거다 
				fos = new FileOutputStream("byte.txt"); 
				
				int readCount = -1; 
				byte buffer[] = new byte[512]; //512byte만큼 읽게 할 byte형 buffer 배열 
				
				while((readCount = fis.read(buffer)) != -1) {
					fos.write(buffer,0,readCount); //0부터? readCount까지 
				}
	
			} catch(Exception e) { 
				e.printStackTrace();
			} finally { //무조건실행? 
				try {
					fos.close(); //닫기 
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			
			long endTime = System.currentTimeMillis();
			System.out.println(endTime - startTime); //실행시간 
			
 		}
	}
```
실행시간: 1  
  
  
byte 배열 선언 안 한 12 코드가 느린 이유  
1byte읽으라 해도 기본이 512byte로 읽어옴  
그래서 한 바이트 읽을 때마다  
512byte에서 1byte쓰고 511byte를 버리는 판을 저지름  
그래서 바이트의 배수를 512로 아예 잡아버리는 게 빠르다는 것이다.  
  
*** 

#### 다른 형으로 하여 "출력"저장 
```
package pack;

import java.io.DataOutputStream;
import java.io.FileOutputStream;

public class Programmers_MidllTest_14<E> { //제너릭 
	public static void main(String[] args) {
			long startTime = System.currentTimeMillis();

			try(
				DataOutputStream out = new DataOutputStream(new FileOutputStream("data.text")); 
					
				){
				out.writeInt(100); //이런 형으로 저장한다 (4byte)
				out.writeBoolean(true); //(1byte갖고저장)
				out.writeDouble(50.5); //(8byte로 저장)
			}catch(Exception e) {
				
			}
			
			long endTime = System.currentTimeMillis();
			System.out.println(endTime - startTime); //실행시간 
			
 		}
	}
```
결과:    d@I@     (내용 깨짐)  

*** 
  
다음 파일의 out을 이용해서 data.txt에 int값 100, double값 3.14를 순서대로 저장하세요.  
  
다양한 타입을 저장하고 싶다면 DataOuputStream을 이용해 보세요.  
  
writeInt()     // 정수값으로 저장  
writeBoolean()   // boolean값으로 저장  
writeDouble()     //double 값으로 저장  
java io객체는 인스턴스를 만들고, 모두 사용하면 close()메소드를 호출해야 했지요.  
하지만 try-with-resources 블럭을 선언하게 되면  
Exception이 발생하지 않았다면 자동으로 close() 할 수 있습니다.  
사용 방법은 try 뒤에 나오는 괄호() 사이에 DataOutputStream등 파일 관련 변수를 선언하면 됩니다.  
  
#### 다양한 타입의 "출력"(저장) - 실습 
```
import java.io.*;

public class DataOutputStreamExam{
    public static void main(String[] args){
        
        try(
            //try의 뒤에나오는 괄호()사이에서 만든 stream은 별도로 close하지 않아도 됩니다.
            DataOutputStream fileout = new DataOutputStream(new FileOutputStream("data.txt"));
        ){
        //이 아래에 out을 이용해서 data.txt에 int값 100, double값 3.14를 저장하세요.
            fileout.writeInt(100);
            fileout.writeDouble(3.14); 
        }
        catch(Exception e){      
        }
    }
}
```
  
*** 


