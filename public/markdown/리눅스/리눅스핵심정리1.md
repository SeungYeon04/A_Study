## 리눅스마스터 핵심 정리 

### **추천 링크 모음** 
https://velog.io/@kimjihong9/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EA%B4%80%EB%A6%AC%EC%82%AC-2%EA%B8%89-%ED%95%84%EA%B8%B0-%EA%B8%B0%EC%B6%9C-%EC%A0%95%EB%A6%AC  

### 1. **시스템 환경변수**
   - **`PATH`**: 실행 파일이 위치한 디렉토리 경로를 저장합니다. 쉘은 이 변수를 참고하여 입력한 명령어를 어떤 디렉토리에서 찾을지 결정합니다.
   - **`HOME`**: 현재 사용자의 홈 디렉토리 경로를 나타냅니다.
   - **`SHELL`**: 현재 사용 중인 쉘의 경로를 나타냅니다. 예: `/bin/bash`.
   - **`LANG`**: 시스템의 언어와 로케일 정보를 설정합니다. 예: `en_US.UTF-8`.
   - **`USER`**: 현재 로그인한 사용자의 이름을 나타냅니다.
   - **`LOGNAME`**: 현재 로그인한 사용자의 이름과 동일하게 설정되는 변수입니다.
   - **`PWD`**: 현재 작업 중인 디렉토리의 경로를 나타냅니다.

### 2. **사용자 정의 환경변수**
- 직접 정의하는 변수로, 특정 세션이나  스크립트에서만 사용할 수 있습니다. 예를 들어,
`export MY_VAR="value"` 형태로 설정할 수 있습니다.  
  
세션 종료 후에도 사용하기 위해서는  
`~/.bashrc` 또는 `~/.bash_profile`에  
추가해야 합니다.  

### 3. **쉘 전용 변수**
   - **`PS1`**: 터미널 기본 프롬포트로
구조는 ```PS1='[\u@\h \W]\$ '```이며  ```[user@hostname ~]$```와 같이 설정됩니다.
   - 리눅스에서 쉘(Shell)은 사용자가 명령어를 입력하고 시스템과 상호작용하는 인터페이스 역할을 합니다. 쉘에는 여러 가지 전용 변수들이 존재하며, 그 중에서도 **`PS1`**과 **`PS2`**는 프롬프트(prompt)와 관련된 변수들로, 사용자에게 명령어 입력을 안내하는 역할을 합니다. 

### **1. `PS1` (Primary Prompt String 1)**

#### **설명**:
- **`PS1`**은 **기본 프롬프트**를 정의하는 변수로, 사용자가 쉘에서 명령어를 입력할 때 표시되는 텍스트입니다. 일반적으로 터미널에 나타나는 프롬프트는 `PS1` 변수에 의해 설정됩니다.

#### **기본 형식**:
- 기본 값은 일반적으로 아래와 같이 설정되어 있습니다:
  ```bash
  PS1='[\u@\h \W]\$ '
  ```
- 각 기호는 다음과 같은 의미를 가집니다:
  - **`\u`**: 현재 사용자의 이름
  - **`\h`**: 호스트 이름 (짧은 형태, 첫 번째 도메인 이름만 표시)
  - **`\W`**: 현재 작업 중인 디렉토리의 이름 (전체 경로가 아닌, 마지막 디렉토리만 표시)
  - **`\$`**: 일반 사용자라면 `$`, 슈퍼유저(root)라면 `#`로 표시

#### **예시**:
- 예를 들어, `PS1='[\u@\h \W]\$ '` 설정 시, 프롬프트는 다음과 같이 표시됩니다:
  ```
  [user@hostname ~]$
  ```
- 현재 사용자가 `user`, 호스트 이름이 `hostname`, 그리고 현재 디렉토리가 홈 디렉토리(`~`)인 경우입니다.

#### **커스터마이징**:
- 사용자는 자신의 `PS1` 프롬프트를 마음대로 커스터마이징할 수 있습니다.
- 예를 들어, 현재 시간과 디렉토리 전체 경로를 포함하도록 설정하려면:
  ```bash
  PS1='\[\e[32m\]\u@\h \[\e[34m\]\w\[\e[0m\] \$ '
  ```
  - **`\[\e[32m\]`**: 텍스트 색상 설정 (초록색)
  - **`\w`**: 현재 작업 중인 디렉토리의 전체 경로
  - **`\[\e[0m\]`**: 색상 리셋 (기본 색상으로 돌아감)

- 결과적으로 프롬프트가 초록색 사용자명과 파란색 경로로 표시됩니다.

### **2. `PS2` (Secondary Prompt String 2)**

#### **설명**:
- **`PS2`**는 **보조 프롬프트**를 정의하는 변수로, 사용자가 명령어를 여러 줄에 걸쳐 입력할 때 표시됩니다. 예를 들어, 백슬래시(`\`)를 사용하여 명령어를 다음 줄로 이어나가면, 그 다음 줄에 나타나는 프롬프트가 `PS2`에 의해 정의됩니다.

#### **기본 형식**:
- 기본 값은 일반적으로 아래와 같이 설정되어 있습니다:
  ```bash
  PS2='> '
  ```
- `PS2`는 기본적으로 `>` 문자로 설정되어 있으며, 이 문자는 명령어의 계속된 입력을 기다리고 있음을 나타냅니다.

#### **예시**:
- 예를 들어, 다음과 같은 명령어를 입력할 때:
  ```bash
  echo "This is a long command \
  that spans multiple lines"
  ```
- 첫 줄을 입력한 후에 Enter를 치면, 다음 줄에 `>` 프롬프트가 표시되며, 명령어의 나머지 부분을 입력할 수 있습니다.

#### **커스터마이징**:
- `PS2` 프롬프트를 다른 문자열로 변경할 수 있습니다.
- 예를 들어, 세 줄을 넘어가는 명령어를 입력할 때 더 명확하게 표시되도록 설정하려면:
  ```bash
  PS2='Continue... '
  ```
- 그러면 다음 줄의 프롬프트가 `Continue... `로 표시됩니다.

### **정리**:
- **`PS1`**: 기본 프롬프트로, 사용자가 쉘에서 명령어를 입력할 때 가장 먼저 볼 수 있는 텍스트입니다. 이를 통해 시스템 정보, 디렉토리, 사용자 이름 등을 포함할 수 있습니다.
- **`PS2`**: 보조 프롬프트로, 명령어가 여러 줄에 걸쳐 있을 때 사용됩니다. 기본적으로 `>`로 표시되지만, 필요에 따라 변경할 수 있습니다.

이 두 변수는 쉘 환경을 사용자 정의하고, 더 효율적이고 사용자 친화적인 작업 환경을 만드는 데 매우 유용합니다.리눅스에서 쉘(Shell)은 사용자가 명령어를 입력하고 시스템과 상호작용하는 인터페이스 역할을 합니다. 쉘에는 여러 가지 전용 변수들이 존재하며, 그 중에서도 **`PS1`**과 **`PS2`**는 프롬프트(prompt)와 관련된 변수들로, 사용자에게 명령어 입력을 안내하는 역할을 합니다. 

### **1. `PS1` (Primary Prompt String 1)**

#### **설명**:
- **`PS1`**은 **기본 프롬프트**를 정의하는 변수로, 사용자가 쉘에서 명령어를 입력할 때 표시되는 텍스트입니다. 일반적으로 터미널에 나타나는 프롬프트는 `PS1` 변수에 의해 설정됩니다.

#### **기본 형식**:
- 기본 값은 일반적으로 아래와 같이 설정되어 있습니다:
  ```bash
  PS1='[\u@\h \W]\$ '
  ```
- 각 기호는 다음과 같은 의미를 가집니다:
  - **`\u`**: 현재 사용자의 이름
  - **`\h`**: 호스트 이름 (짧은 형태, 첫 번째 도메인 이름만 표시)
  - **`\W`**: 현재 작업 중인 디렉토리의 이름 (전체 경로가 아닌, 마지막 디렉토리만 표시)
  - **`\$`**: 일반 사용자라면 `$`, 슈퍼유저(root)라면 `#`로 표시

#### **예시**:
- 예를 들어, `PS1='[\u@\h \W]\$ '` 설정 시, 프롬프트는 다음과 같이 표시됩니다:
  ```
  [user@hostname ~]$
  ```
- 현재 사용자가 `user`, 호스트 이름이 `hostname`, 그리고 현재 디렉토리가 홈 디렉토리(`~`)인 경우입니다.

#### **커스터마이징**:
- 사용자는 자신의 `PS1` 프롬프트를 마음대로 커스터마이징할 수 있습니다.
- 예를 들어, 현재 시간과 디렉토리 전체 경로를 포함하도록 설정하려면:
  ```bash
  PS1='\[\e[32m\]\u@\h \[\e[34m\]\w\[\e[0m\] \$ '
  ```
  - **`\[\e[32m\]`**: 텍스트 색상 설정 (초록색)
  - **`\w`**: 현재 작업 중인 디렉토리의 전체 경로
  - **`\[\e[0m\]`**: 색상 리셋 (기본 색상으로 돌아감)

- 결과적으로 프롬프트가 초록색 사용자명과 파란색 경로로 표시됩니다.

### **2. `PS2` (Secondary Prompt String 2)**

#### **설명**:
- **`PS2`**는 **보조 프롬프트**를 정의하는 변수로, 사용자가 명령어를 여러 줄에 걸쳐 입력할 때 표시됩니다. 예를 들어, 백슬래시(`\`)를 사용하여 명령어를 다음 줄로 이어나가면, 그 다음 줄에 나타나는 프롬프트가 `PS2`에 의해 정의됩니다.

#### **기본 형식**:
- 기본 값은 일반적으로 아래와 같이 설정되어 있습니다:
  ```bash
  PS2='> '
  ```
- `PS2`는 기본적으로 `>` 문자로 설정되어 있으며, 이 문자는 명령어의 계속된 입력을 기다리고 있음을 나타냅니다.

#### **예시**:
- 예를 들어, 다음과 같은 명령어를 입력할 때:
  ```bash
  echo "This is a long command \
  that spans multiple lines"
  ```
- 첫 줄을 입력한 후에 Enter를 치면, 다음 줄에 `>` 프롬프트가 표시되며, 명령어의 나머지 부분을 입력할 수 있습니다.

#### **커스터마이징**:
- `PS2` 프롬프트를 다른 문자열로 변경할 수 있습니다.
- 예를 들어, 세 줄을 넘어가는 명령어를 입력할 때 더 명확하게 표시되도록 설정하려면:
  ```bash
  PS2='Continue... '
  ```
- 그러면 다음 줄의 프롬프트가 `Continue... `로 표시됩니다.

### **정리**:
- **`PS1`**: 기본 프롬프트로, 사용자가 쉘에서 명령어를 입력할 때 가장 먼저 볼 수 있는 텍스트입니다. 이를 통해 시스템 정보, 디렉토리, 사용자 이름 등을 포함할 수 있습니다.
- **`PS2`**: 보조 프롬프트로, 명령어가 여러 줄에 걸쳐 있을 때 사용됩니다. 기본적으로 `>`로 표시되지만, 필요에 따라 변경할 수 있습니다.

이 두 변수는 쉘 환경을 사용자 정의하고, 더 효율적이고 사용자 친화적인 작업 환경을 만드는 데 매우 유용합니다.
- **`PS2`**: 여러 줄 명령어 입력 시 사용하는 보조 프롬프트를 정의합니다. 기본값은 `>`.  
   - **`HISTFILE`**: 명령어 기록이 저장되는 파일의 경로를 설정합니다. 일반적으로 `~/.bash_history`로 설정됩니다.
   - **`HISTSIZE`**: 명령어 기록의 최대 저장 개수를 설정합니다.
   - **`EDITOR`**: 시스템 기본 텍스트 편집기를 설정합니다. 예를 들어, `vi`, `nano` 등을 사용할 수 있습니다.

### 4. **터미널 관련 환경변수**
   - **`TERM`**: 현재 터미널 유형을 나타냅니다. `xterm`, `vt100` 등으로 설정됩니다.  
   - **`COLORTERM`**: 터미널에서 색상을 지원하는지 여부를 설정합니다.  
  
`export`, `env`, `set` 등의  
명령어를 통해 설정하거나 확인할 수 있다. 

`tar` 명령어의 기본 옵션과 시험에서 자주 출제될 수 있는 주요 압축 확장자 옵션을 정리해드리겠습니다.

*** 

### 1. **tar 기본 옵션**
   - **`c`**: 아카이브 생성 (`create`).
     - 예: `tar -cf archive.tar directory/`
   - **`x`**: 아카이브 해제 (`extract`).
     - 예: `tar -xf archive.tar`
   - **`v`**: 작업의 진행 상황을 화면에 출력 (`verbose`).
     - 예: `tar -cvf archive.tar directory/`
   - **`f`**: 아카이브 파일 이름 지정 (`file`).
     - 예: `tar -cf archive.tar directory/`
   - **`t`**: 아카이브의 내용 목록 (`list`).
     - 예: `tar -tf archive.tar`

### 확장자 옵션 
- **기본 옵션**: `c`, `x`, `v`, `f`, `t`
- **압축 옵션**:
  - **`z`**: `gzip` 압축 (`.tar.gz`)
  - **`j`**: `bzip2` 압축 (`.tar.bz2`)
  - **`J`**: `xz` 압축 (`.tar.xz`)
  - **`a`**: 자동 압축 형식 선택 (`.tar.gz`, `.tar.bz2`, `.tar.xz` 등 확장자에 따라 자동으로 결정)

### 파일 압축 해제 
- **`gunzip`**: `.gz` 파일 해제
- **`bunzip2`**: `.bz2` 파일 해제
- **`unxz`**: `.xz` 파일 해제
- **`unzip`**: `.zip` 파일 해제
- **`unrar`**: `.rar` 파일 해제
- **`7z`**: `.7z` 파일 해제
  
### fdisk 옵션 
-l: 디스크의 파티션 테이블을 나열합니다. 예: fdisk -l  
-a: 파티션 부트 플래그를 설정합니다. 이 옵션은 fdisk의 대화형 모드에서 사용됩니다.  
-b: 블록 크기를 설정합니다. 이는 디스크 작업 시 사용할 블록의 크기를 지정합니다.  
-c: 파티션 테이블의 호환 모드를 설정합니다. (특히, DOS 또는 GPT 파티션 테이블을 선택할 때 사용)  
-h: 도움말을 출력합니다. 모든 사용 가능한 옵션과 함께 fdisk의 기본 사용법을 보여줍니다.  
-t: 파티션의 타입을 설정합니다. 파티션의 유형을 변경할 때 사용됩니다.  
예를 들어, t 명령어를 입력한 후, 파티션 번호와 새로운 파티션 타입 코드를 입력하여 변경할 수 있습니다.  
-p: 파티션 테이블을 표시합니다. fdisk의 대화형 모드에서 사용할 수 있습니다.  
-n: 새로운 파티션을 생성합니다. 새로운 파티션을 추가할 때 사용됩니다.  
-d: 기존 파티션을 삭제합니다. 삭제할 파티션을 지정하여 제거할 수 있습니다.  
-w: 파티션 테이블을 저장하고 종료합니다. 작업한 내용을 디스크에 기록합니다.  
-x: fdisk의 확장 파티션 관련 명령어를 설정합니다.  
  
### 파일 시스템 종류 
mke2fs: ext2, ext3, ext4 파일 시스템을 생성합니다.  
e2fsck: ext2, ext3, ext4 파일 시스템의 체크 및 복구를 담당합니다.  
  
- xfs  
mkfs.xfs: XFS 파일 시스템을 생성하는 도구입니다.  
xfs_repair: XFS 파일 시스템의 체크 및 복구를 담당합니다.  
btrfs: Btrfs는 최신 파일 시스템으로, 스냅샷, 압축, RAID와 같은 고급 기능을 제공합니다.  
  
- Btrfs  
mkfs.btrfs: Btrfs 파일 시스템을 생성하는 도구입니다.  
btrfs check: Btrfs 파일 시스템의 체크 및 복구를 담당합니다.  
vfat (FAT32): FAT32는 다양한 운영 체제에서 호환되는 파일 시스템입니다.  

- vfat  
mkfs.vfat 또는 mkfs.fat: FAT32 파일 시스템을 생성하는 도구입니다.  
fsck.fat: FAT 파일 시스템의 체크 및 복구를 담당합니다.  
ntfs: NTFS는 주로 윈도우즈에서 사용하는 파일 시스템입니다.  

- NTFS  
mkfs.ntfs: NTFS 파일 시스템을 생성하는 도구입니다.  
ntfsfix: NTFS 파일 시스템의 체크 및 복구를 담당합니다.  
reiserfs: ReiserFS는 빠른 파일 시스템으로 알려져 있으며, 특히 작은 파일 처리에 유리합니다.  

- ReiserFS  
mkfs.reiserfs: ReiserFS 파일 시스템을 생성하는 도구입니다.  
reiserfsck: ReiserFS 파일 시스템의 체크 및 복구를 담당합니다.  
zfs: ZFS는 고급 파일 시스템으로, 데이터 무결성 검사, 스냅샷, RAID 기능을 제공합니다.  

- ZFS  
zpool create: ZFS 풀을 생성하는 명령어입니다.  
zfs create: ZFS 파일 시스템을 생성하는 명령어입니다.  
xfs: XFS는 고성능 파일 시스템으로 대용량 파일 시스템과 많은 파일들을 효율적으로 처리합니다.  

- XFS  
mkfs.xfs: XFS 파일 시스템을 생성합니다.  
xfs_repair: XFS 파일 시스템을 체크하고 복구합니다.  
  
#### 파일시스템 예시 해석 
```
mke2fs -j -b 8192 -R stride=32 /dev/md0
```
저널링을 활성화하여 ext3 또는 ext4 파일 시스템을 생성합니다.  
블록 크기를 8192 바이트(8KB)로 설정하여 파일 시스템을 구성합니다.  
RAID 성능을 최적화하기 위해 stride 값을 32로 설정하여 RAID 배열에서 데이터를 저장하는 방식에 영향을 줍니다.  
**RAID 장치 /dev/md0**에 파일 시스템을 생성합니다.  

### 파일시스템 옵션  
-b: 블록 크기를 설정합니다. 예: -b 4096 (기본값은 1024 바이트).  
-i: inode 당 바이트 수를 설정합니다. 예: -i 16384 (기본값은 16384).  
-L: 파일 시스템의 레이블을 설정합니다. 예: -L mylabel.  
-m: 루트 디렉토리에 예약된 블록의 비율을 설정합니다. 예: -m 1 (기본값은 5%).  
-n: 파일 시스템을 생성할 때 블록 수를 설정합니다.  
-O: 파일 시스템의 옵션을 설정합니다. 예: -O dir_index (인덱스 디렉토리 옵션).  
-t: 파일 시스템의 타입을 설정합니다. 예: -t ext3.  
-R: 파일 시스템의 예약 옵션을 설정합니다. 예: -R stride=32.  
-E: 확장 파일 시스템 옵션을 설정합니다. 예: -E test_dummy=1.  
-f: 파일 시스템을 강제로 생성합니다.  
-j: 파일 시스템을 ext3으로 생성합니다. (ext3는 ext2의 저널링 버전입니다.)  
-t: 파일 시스템의 타입을 설정합니다. 예: -t ext3 (ext2는 기본값).  
-c: 파일 시스템을 생성하기 전에 블록 장치의 배드 블록을 검사합니다.  
-i: 각 inode가 차지하는 블록의 수를 설정합니다. 예: -i 16384.  
  
### OSI 7계층 별 전송 단위  
1 bit  
2 frame  
3 packet/datagram  
4 record/segment  
5,6,7 message  
  
### A클래스(8bit): 11111111 00000000 00000000 00000000 [255.0.0.0]  
B클래스(16bit): 11111111 11111111 00000000 00000000 [255.255.0.0]  
C클래스(24bit): 11111111 11111111 11111111 00000000 [255.255.255.0]  
1 -> 네트워크  
0 -> 호스트  
호스트를 가장 많이 쓸 수 있는 클래스는 A클래스  

### A B C 클래스별 대역  

#### 1. **클래스 A (Class A)**
   - **범위**: `1.0.0.0` ~ `126.0.0.0`
   - **네트워크 식별자**: 첫 번째 옥텟 (8비트)
   - **호스트 식별자**: 나머지 24비트
   - **서브넷 마스크**: `255.0.0.0` (`/8`)
   - **특징**: 매우 큰 네트워크를 구성할 수 있습니다. 각 네트워크는 최대 16,777,214개의 호스트를 가질 수 있습니다.
   - **예시**: `10.0.0.1`

#### 2. **클래스 B (Class B)**
   - **범위**: `128.0.0.0` ~ `191.255.0.0`
   - **네트워크 식별자**: 처음 두 개의 옥텟 (16비트)
   - **호스트 식별자**: 나머지 16비트
   - **서브넷 마스크**: `255.255.0.0` (`/16`)
   - **특징**: 중간 크기의 네트워크에 사용됩니다. 각 네트워크는 최대 65,534개의 호스트를 가질 수 있습니다.
   - **예시**: `172.16.0.1`

#### 3. **클래스 C (Class C)**
   - **범위**: `192.0.0.0` ~ `223.255.255.0`
   - **네트워크 식별자**: 처음 세 개의 옥텟 (24비트)
   - **호스트 식별자**: 나머지 8비트
   - **서브넷 마스크**: `255.255.255.0` (`/24`)
   - **특징**: 작은 네트워크에 사용됩니다. 각 네트워크는 최대 254개의 호스트를 가질 수 있습니다.
   - **예시**: `192.168.0.1`

#### 4. **클래스 D (Class D)**
   - **범위**: `224.0.0.0` ~ `239.255.255.255`
   - **용도**: 멀티캐스트 주소용으로 예약된 범위입니다. 네트워크 및 호스트 구분이 없습니다.

#### 5. **클래스 E (Class E)**
   - **범위**: `240.0.0.0` ~ `255.255.255.255`
   - **용도**: 실험적 목적으로 예약된 범위로, 일반적인 네트워킹에서는 사용되지 않습니다.

이 클래스 기반의 IP 주소 구분은 요즘에는 거의 사용되지 않지만, 전통적인 네트워크 구성에서 중요한 역할을 했습니다. 현재는 CIDR(클래스 없는 도메인 라우팅) 방식을 통해 더 유연하게 네트워크를 구성합니다.
